package ssh

import (
	"context"
	"net"

	"github.com/myLogic207/cinnamon/patchssh/ui"
	"github.com/myLogic207/gotils/config"
	"github.com/myLogic207/pepper/base"
	"golang.org/x/crypto/ssh"
)

var defaultServerConfig = map[string]interface{}{
	"LOGGER": map[string]interface{}{
		"PREFIX":       "SSH-SERVER",
		"PREFIXLENGTH": 20,
	},
	"ADDRESS": "127.0.0.1",
	"PORT":    2222,
	"WORKERS": 100,
	"TIMEOUT": "5s",
	"TYPE":    "tcp",
	"KEY":     "autogenerated",
}

type ChannelHandler func(ctx context.Context, channel ssh.NewChannel) error

type RequestHandler func(ctx context.Context, channel ssh.Channel, req *ssh.Request) error

type SSHServer struct {
	*base.Server
	// supportedKeyTypes is the list of supported key types. It is set when the
	// server is created and is used to validate the requested client's public
	// keys.
	supportedKeyTypes []string
	// keystore is the keystore used to store the host key and client keys.
	// it also provides the ability to generate new client keys.
	keystore  Keystore
	sshConfig *ssh.ServerConfig
	// ChannelHandlers allow overriding the built-in session handlers or provide
	// extensions to the protocol, such as tcpip forwarding. By default only the
	// "session" handler is enabled.
	ChannelHandlers map[string]ChannelHandler
	// RequestHandlers allow overriding the built-in request handlers or provide
	// extensions to the protocol, such as tcpip forwarding. By default no
	// handlers are enabled.
	RequestHandlers map[string]RequestHandler
}

func NewSSHServer(serverOptions config.Config, keystore Keystore) (*SSHServer, error) {
	cnf := config.NewWithInitialValues(defaultServerConfig)
	if err := cnf.Merge(serverOptions, true); err != nil {
		return nil, err
	}

	server := &SSHServer{
		supportedKeyTypes: []string{
			ssh.KeyAlgoED25519,
			ssh.KeyAlgoRSA,
		},
	}
	var err error
	server.Server, err = base.NewServer(cnf, server.connHandler)
	if err != nil {
		return nil, err
	}
	server.sshConfig, err = server.loadSSHConfig()
	if err != nil {
		return nil, err
	}
	return server, nil
}

func (s *SSHServer) connHandler(ctx context.Context, conn net.Conn, i ...interface{}) error {
	sshConn, chans, reqs, err := ssh.NewServerConn(conn, s.sshConfig)
	if err != nil {
		return err
	}
	go ssh.DiscardRequests(reqs)
	defer sshConn.Close()

	if err := s.Connection(ctx, sshConn, chans); err != nil {
		return err
	}
	return nil
}

func (s *SSHServer) loadSSHConfig() (*ssh.ServerConfig, error) {
	maxTries, _ := s.Config.GetInt("MAXAUTHTRIES")
	version, _ := s.Config.GetString("SERVERVERSION")
	sshConfig := &ssh.ServerConfig{
		NoClientAuth:         false,
		MaxAuthTries:         maxTries,
		ServerVersion:        version,
		AuthLogCallback:      s.AuthLogCallback,
		PublicKeyCallback:    s.PublicKeyCallback,
		NoClientAuthCallback: s.NoAuthCallback,
		PasswordCallback:     s.PasswordAuth,
		// KeyboardInteractiveCallback: s.loginManager.KeyboardInteractiveAuth,
		BannerCallback: ui.Banner,
		PublicKeyAuthAlgorithms: []string{
			ssh.KeyAlgoED25519,
			ssh.KeyAlgoRSA,
		},
	}

	return sshConfig, nil
}

func (s *SSHServer) Listen(ctx context.Context) error {
	signer, err := s.keystore.GetHostKey(ctx)
	if err != nil {
		return err
	}

	s.sshConfig.AddHostKey(signer)

	return s.Server.Listen(ctx)
}
