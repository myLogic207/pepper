package ssh

import (
	"context"
	"fmt"
	"net"
	"strconv"

	"github.com/myLogic207/gotils/config"
	"github.com/myLogic207/gotils/logger"
	"github.com/myLogic207/pepper/base"
	"golang.org/x/crypto/ssh"
)

var defaultServerConfig = map[string]interface{}{
	"LOGGER": map[string]interface{}{
		"PREFIX":      "SSH-SERVER",
		"COLUMLENGTH": 20,
	},
	"SERVER": map[string]interface{}{
		"ADDRESS": "127.0.0.1",
		"PORT":    2222,
		"WORKERS": 100,
		"TIMEOUT": "5s",
		"TYPE":    "tcp",
	},
	"KEY":           "autogenerated",
	"MAXAUTHTRIES":  3,
	"SERVERVERSION": "SSH-2.0-PEPPER",
}

type ChannelHandler func(ctx context.Context, channel ssh.NewChannel) error
type RequestHandler func(ctx context.Context, channel ssh.Channel, req *ssh.Request) error
type SubsystemHandler func(ctx context.Context, subsystem string) error

type Server struct {
	base   *base.Server
	logger logger.Logger
	config *config.Config
	// supportedKeyTypes is the list of supported key types. It is set when the
	// server is created and is used to validate the requested client's public
	// keys.
	supportedKeyTypes []string
	// keystore is the keystore used to store the host key and client keys.
	// it also provides the ability to generate new client keys.
	keystore  Keystore
	sshConfig *ssh.ServerConfig
	// ChannelHandlers allow overriding the built-in session handlers or provide
	// extensions to the protocol, such as tcpip forwarding. By default only the
	// "session" handler is enabled.
	ChannelHandlers map[string]ChannelHandler
	// RequestHandlers allow overriding the built-in request handlers or provide
	// extensions to the protocol, such as tcpip forwarding. By default no
	// handlers are enabled.
	RequestHandlers map[string]RequestHandler
	// SubsystemHandlers allow overriding the built-in subsystem handlers or
	// provide extensions to the protocol, such as sftp. By default no handlers
	// are enabled.
	SubsystemHandlers map[string]SubsystemHandler
	BannerString      string
	BannerFunc        func(conn ssh.ConnMetadata) string
}

func (s *Server) Listen(ctx context.Context, serverOptions *config.Config, keystore Keystore) error {
	if s.base == nil {
		s.base = &base.Server{}
	}
	if s.config == nil {
		cnf, err := config.WithInitialValuesAndOptions(ctx, defaultServerConfig, serverOptions)
		if err != nil {
			return err
		}
		s.config = cnf
	}

	loggerConfig, _ := s.config.GetConfig(ctx, "LOGGER")
	logger, err := logger.Init(ctx, loggerConfig)
	if err != nil {
		return err
	}
	s.base.Logger = logger
	s.logger = logger

	if s.keystore == nil {
		s.keystore = keystore
	}

	s.supportedKeyTypes = []string{
		ssh.KeyAlgoED25519,
		ssh.KeyAlgoRSA,
	}
	s.ChannelHandlers = make(map[string]ChannelHandler)
	s.RequestHandlers = make(map[string]RequestHandler)
	s.SubsystemHandlers = make(map[string]SubsystemHandler)

	sshConfig, err := s.loadSSHConfig(ctx)
	if err != nil {
		return err
	}
	signer, err := s.keystore.GetHostKey(ctx)
	if err != nil {
		return err
	}
	sshConfig.AddHostKey(signer)
	s.sshConfig = sshConfig
	s.logger.Info(ctx, "SSH Config loaded")

	serverConfig, _ := s.config.GetConfig(ctx, "SERVER")
	return s.base.Listen(ctx, serverConfig)
}

func (s *Server) Serve(ctx context.Context) error {
	return s.base.Serve(ctx, s.connHandler)
}

func (s *Server) connHandler(ctx context.Context, conn net.Conn) error {
	sshConn, chans, reqs, err := ssh.NewServerConn(conn, s.sshConfig)
	if err != nil {
		return err
	}
	go ssh.DiscardRequests(reqs)
	defer sshConn.Close()

	if err := s.WorkConnect(ctx, sshConn, chans); err != nil {
		return err
	}
	return nil
}

func (s *Server) loadSSHConfig(ctx context.Context) (*ssh.ServerConfig, error) {
	maxTriesRaw, _ := s.config.Get(ctx, "MAXAUTHTRIES")
	maxTries, err := strconv.Atoi(maxTriesRaw)
	if err != nil {
		return nil, fmt.Errorf("could not parse max auth tries: %w", err)
	}
	version, _ := s.config.Get(ctx, "SERVERVERSION")
	sshConfig := &ssh.ServerConfig{
		NoClientAuth:         false,
		MaxAuthTries:         maxTries,
		ServerVersion:        version,
		AuthLogCallback:      s.AuthLogCallback,
		PublicKeyCallback:    s.PublicKeyCallback,
		NoClientAuthCallback: s.NoAuthCallback,
		PasswordCallback:     s.PasswordAuth,
		// KeyboardInteractiveCallback: s.loginManager.KeyboardInteractiveAuth,
		BannerCallback: s.generateBanner,
		PublicKeyAuthAlgorithms: []string{
			ssh.KeyAlgoED25519,
			ssh.KeyAlgoRSA,
		},
	}

	return sshConfig, nil
}

func (s *Server) AddSupportedKeyType(keyType string) {
	s.supportedKeyTypes = append(s.supportedKeyTypes, keyType)
}

func (s *Server) RemoveSupportedKeyType(keyType string) {
	for i, t := range s.supportedKeyTypes {
		if t == keyType {
			s.supportedKeyTypes = append(s.supportedKeyTypes[:i], s.supportedKeyTypes[i+1:]...)
		}
	}
}

func (s *Server) generateBanner(conn ssh.ConnMetadata) string {
	if s.BannerFunc != nil {
		return s.BannerFunc(conn)
	} else if s.BannerString != "" {
		return s.BannerString
	} else {
		return fmt.Sprintf("SSH-2.0-%s", s.sshConfig.ServerVersion)
	}
}

func (s *Server) Stop(ctx context.Context) error {
	return s.base.Stop(ctx)
}

func (s *Server) GetAddr() net.Addr {
	return s.base.GetListener().Addr()
}
